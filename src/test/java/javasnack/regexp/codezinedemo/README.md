# CodeZine連載「正規表現エンジンを作ろう」をJavaで挑戦

以下の連載において Python で書かれている正規表現エンジンを、Javaで書くのに挑戦。

- `正規表現エンジンを作ろう連載一覧：CodeZine（コードジン）`
  - https://codezine.jp/article/corner/237

Javaで書いた場合、命名規約やコーディングの慣習などでPython版から大分変更となったため、一旦著作権は自身のものとしてライセンスも javasnack 全体のAPL2にしています。問題あればご連絡ください。

なお元の連載記事での Python コードは、連載記事 (6) にzipでダウンロードするリンクがある。
Python コードを確認したい場合は、先に(6)からダウンロードしておくのを推奨する。

以下、Javaで書いた場合の作業ログおよびその他補足メモ：

## [1] 連載記事(1)

元記事URL : https://codezine.jp/article/detail/3039

初回記事なので、正規表現の概要解説と有限オートマトンの導入説明。

ポイント: 正規表現は、文字入力をイベントとした有限オートマトンのモデルで考えることができる。文字による状態遷移で最終的に「受理状態」となれば、マッチしたと考える。

- 有限オートマトン (Finite Automaton)
  - https://ja.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3
- 非決定性オートマトン (Nondeterministic Finite Automaton : NFA)
  - ある入力文字に対して、遷移先(矢印)が複数存在する。
  - 空文字(ε)での遷移を許可している。
  - このため、ある文字によりどの状態に遷移するか、あるいは空文字として遷移するか、複数の選択肢が発生することとなり、どれになるか決定できない。複数の選択肢をそれぞれ試す総当りが必要となる。
    - 幅優先 : 選択しうる状態を集合とし、全ての可能性を保持しつつマッチするまで広げて行く
    - 深さ優先 : 選択肢を適当に選んで失敗するまで潜り、失敗したら戻って別の選択肢をやり直す (バックトラック)
- 決定性オートマトン (Deterministic Finite Automaton : DFA)
  - 非決定性が無いオートマトン
  - 全ての入力文字に対して、必ず矢印が1つだけ存在する。= 1つの文字で、複数の状態のどれかに遷移する、ということは無い。また、文字空間全てについてそれぞれただ1つの遷移先が存在する。
  - 空文字(ε)での遷移も許可していない。
- 前方一致
  - この連載記事においては、マッチングを文字列の先頭から1文字ずつ受けて判定していく。
  - 全文一致の場合は最後まで入力して「受理状態」となることがマッチ条件だが、前方一致の場合は途中で「受理状態」となればそこで切り上げてOK.
- 後方一致
  - この連載記事においては、マッチ対象の文字列を1文字ずつ後方に短くしていきながら判定する。
  - `cat|rat` が `autocrat` にマッチするケースを考えると、後方一致では `autocrat`, `utocrat`, `tocrat`, ... と短くしていき、最終的に `rat` でマッチする。


## [2] 連載記事(2)

元記事URL : https://codezine.jp/article/detail/3154

連載記事の主目的であるDFA正規表現エンジンの開発に着手する。
実装予定の正規表現としては以下の文法をサポート予定。

- `A|B` : A or B (和集合)
- `AB` : 文字列AB (連結)
- `A*` : Aの0個以上の繰り返し
- `(...)` : 演算の優先順位
- `バックスラッシュ + 任意文字` : 1文字の任意文字(エスケープ)

内部的にはまずNFAとして正規表現を解析し、それをDFAに変換する方式としている。
そのため実装の流れは以下のようになる。

1. NFAとDFAの実装
2. 正規表現のコンパイル (構文木の作成)
3. 構文木からNFAを作成
4. NFAからDFAへの変換
5. 全てを組み合わせて完成

### [2-1] NFAの内部表現を Java で実装

NFAの数学的な定義:

1. 状態の集合（丸）
   - 遷移関数の戻り値 + 開始状態 + 受理状態の集合 となるので、それらを定義すれば自動的に定まる。
2. 文字の集合（Unicode文字）
   - Java での `Character` 型を利用する。
3. 遷移関数（矢印）
   - 引数: 今の状態, 文字 **or 空文字（ε）**
   - 戻り値: 次の状態 **の集合**
4. 開始状態（最初の矢印がさす丸）
5. 受理状態の集合（二重丸）

ここで「状態」をどう実装するか？
NFAを表現する図を見ていくと、状態（丸）の中に数字が入っており、状態1, 2, 3, ... として表現している。
元の連載記事ではPython 2系ということもあり、型が明示されていないものの、サンプルコードからそのまま整数値として実装していることが伺える。
よって、Javaで実装するときもそのまま整数値(int, Integer)として実装してみる。
状態を整数値として表現するので、遷移関数とその引数もおおよそ以下のようにJavaで表現できる。

```java
int someStateTransitionFunction(int currentState, char inputCharacter) {
}
```

ただし、今考えているのはNFAにおける遷移関数であるため、戻り値 = 遷移先の状態は複数を取りうる。

元の連載記事では Python の frozenset を使ってこのような「状態の集合」を表現している。
setではなくfrozensetを使っている理由としては、後半のNFAをDFAに変換するところで「集合それ自体を要素とした集合」(集合の入れ子)を扱う必要が出てくるが、 [setはmutableでハッシュ値を持たない](https://docs.python.org/ja/3/library/stdtypes.html#set-types-set-frozenset) ため他のコレクションの要素とすることが出来ない。
そこでimmutableでハッシュ値を持てるfrozensetを採用し、「集合(frozenset)それ自体を要素とした集合(frozenset)」を実現している。

Javaにおいては、現段階では `Set<Integer>` としておけばまずは無難と思われる。
Python と異なり Set インスタンスそれ自体を Set に入れた `Set<Set<Integer>>` が Java では可能であり、インスタンス生成の際は実装クラスとして `HashSet<Integer>` をひとまず採用してみる。

さらにもう一点、NFAでは空文字列(ε)も扱える必要がある。
これを表現するため、入力文字を `java.util.Optional<Character>` にする。
したがって、以下のメソッドがNFAにおける遷移関数の Java 版となる。

```java
Set<Integer> someNfaStateTransitionFunction(int currentState, Optional<Character>) {
}
```

これをJava8の関数型インターフェイスで表現し、ソースコードを読みやすくする。

```java
@FunctionalInterface
public interface NfaStateTransitFunction {
    Set<Integer> apply(int currentState, Optional<Character> inputCharacter);
}
```

連載の元記事のPythonコードを見ると、「イベント x 状態遷移」の組み合わせはこの遷移関数に全て押し込める形になっている。
よってNFA全体を表現するオブジェクトとしては、遷移関数 + 初期状態 + 受理状態の集合、の3つのパラメータを保持する。
遷移関数について Java 8 の関数型インターフェイスを活用したのが、以下のJava版 NFA オブジェクトとなる。
(以下、特に断りなく lombok のアノテーションを使用する)

```java
@ToString
@EqualsAndHashCode
@AllArgsConstructor(staticName = "of")
public class Nfa {
    /** transition function */
    public final NfaStateTransitFunction transition;
    /** starting state */
    public final int start;
    /** set of acceptable states */
    public final Set<Integer> accept;
}
```

このクラスは結局何を表現するかというと、特定の正規表現に対応した状態遷移の「設計図」を提供する。
メソッドが何も定義されていないことからも分かる通り、これは単に設計図でしかなく、実際に入力文字を与えて状態遷移を管理する実行エンジンが別に必要となり、連載記事(3) 以降でそれが紹介される。

### [2-2] DFAの内部表現を Java で実装

DFAの数学的な定義:

1. 状態の集合（丸）
2. 文字の集合（Unicode文字）
3. 遷移関数（矢印）
   - 引数: 今の状態, 文字
   - 戻り値: 次の状態
4. 開始状態（最初の矢印がさす丸）
5. 受理状態の集合（二重丸）

NFAとほぼ同じで、異なるのは遷移関数の引数と戻り値になる。
DFAにおいては引数の文字は空文字を扱わない。
また、戻り値についても次の状態は常に1つに定めるのがDFAの定義なので、集合ではなく単一の値を返すことになる。
したがってDFAの遷移関数をJavaで表現すると、以下のようなメソッドになる。

```java
int someDfaStateTransitionFunction(int currentState, char inputCharacter) {
}
```

これをJava8の関数型インターフェイスで表現し、ソースコードを読みやすくする。

```java
@FunctionalInterface
public interface DfaStateTransitFunction {
    int apply(int currentState, char inputCharacter);
}
```

DFA全体を表現する Java オブジェクトは、NFAと同様に以下のようになり、遷移関数の定義だけが異なる。

```java
@ToString
@EqualsAndHashCode
@AllArgsConstructor(staticName = "of")
public class Dfa {
    /** transition function */
    public final DfaStateTransitFunction transition;
    /** starting state */
    public final int start;
    /** set of acceptable states */
    public final Set<Integer> accept;
}
```

このクラスもNFAと同様、特定の正規表現に対応した状態遷移の「設計図」を提供する。
したがって実際に入力文字を与えて状態遷移を管理する実行エンジンが別に必要となり、そのランタイムを続けて実装していく。

### [2-3] DFAのシミュレーション: DfaRuntime

DFAについて、実際に入力文字列から1文字ずつ与えて状態を変化させ、最終的に受理状態となる = マッチしたかを判定するランタイム: DfaRuntime クラスを作る。
元の連載記事でのPythonサンプルコードを元に、Java版を組み上げてみる。

ランタイムが必要とする情報は、DFAの設計図である。
管理する情報としては現在状態となるので、以下のような field + constructor を組める。

```java
public class DfaRuntime {
    private final Dfa dfa;
    private int currentState;

    public DfaRuntime(final Dfa dfa) {
        this.dfa = dfa;
        this.currentState = dfa.start;
    }
}
```

続けて1文字を入力し、状態遷移関数を呼び出して次の状態を取得、更新するメソッドを用意する。
これは詳細な実装に係る内部向けの処理なので private とし、公開用には別途扱いやすいAPIを用意する(後述)

```java
private void transit(final char c) {
    this.currentState = dfa.transition.apply(Integer.valueOf(currentState), Character.valueOf(c));
}
```

現在の状態が受理状態に含まれるか判定するメソッドを用意する。

```java
private boolean isCurrentStatusAcceptable() {
    return this.dfa.accept.contains(Integer.valueOf(currentState));
}
```

最後に、入力文字列をまとめて受け取り1文字ずつ transit() させて結果を呼び出すショートカット用公開APIを用意する。

```java
public boolean accept(final String input) {
    input.codePoints().mapToObj(c -> (char) c).forEach(c -> this.transit(c));
    return this.isCurrentStatusAcceptable();
}
```

## [3] 連載記事(3), (4)

元記事URL:

- (3) : 正規表現のコンパイラの作成
  - https://codezine.jp/article/detail/3158
- (4) : コンパイラが生成した構文木からNFAを作る
  - https://codezine.jp/article/detail/3164

元記事では最初にコンパイラを作成し、次にコンパイラが生成した構文木からNFAを作る流れで解説している。
これは、以下の処理の流れをその順番通りに作っていく解説となっている。

1. 字句解析(lexer)
2. 構文解析(parser) -> 構文木生成(node)
3. InterpreterパターンによるNFAの生成 (Interpreter パターンについては参考資料[4] - [6] 参照)

自分の場合、コンパイラ関連の技術に疎いこともあり、この流れではうまく理解できなかった。
というのも、特に構文解析とNFAの生成がお互いに強く関連していて、構文解析のコードがNFAを生成するInterpreterパターンに強く依存している。
つまり元の連載記事(3)のサンプルコードを理解するには、その先の(4)のサンプルコードを理解する必要がある。
その順番に気づかずに (3) を読んでいると、(4)に登場するクラス = その時点では未解説のクラスがいきなり登場してパニックに陥る。

そこでこちらの作業メモでは、自分と同様に混乱した読者向けに、元記事とは異なる順序で解説を試みる。
文法や構文木など、概念的な部分を最初に押さえるのは元記事の流れ通りだが、その後、Interpreterパターンの実装を先に行い、依存コンポーネントが出来上がってから上に戻ってコンパイラを作成する流れとしている。

1. 実装する正規表現の機能と文法を考える。
2. 文法をもとに必要となる構文木を考える。
3. その構文木を元に動的に生成可能なNFAの表現方法を考え、実装する。
4. NFAの実装を利用した、構文木処理(lexer + parser)を実装する。

### [3-1] 実装する正規表現の機能と文法

元の連載記事 (2) にある通り以下の機能を実装する。(再掲)

- `A|B` : A or B (和集合)
- `AB` : 文字列AB (連結)
- `A*` : Aの0個以上の繰り返し
- `(...)` : 演算の優先順位
- `バックスラッシュ + 任意文字` : 1文字の任意文字(エスケープ)

これをどう文法規則に落とし込むか。
元の連載記事(2), (3)から推測するに、以下の流れで組み立てていったものと思われる。

1. `A|B` の左右の要素は、そのまま正規表現の入れ子になる。つまりこれが上位の文法規則になる。
2. `AB` は文字列の連結というより、正規表現の連結と考える。
3. `A*` は文字の繰り返しというより、正規表現の繰り返しと考える。
4. `(...)` の中身は正規表現または文字となる。 -> これを一番底となる要素における。
5. `(...)` を底になる要素と置けば、また通常の1文字も底となる要素にできる。 
   - `(` + 正規表現 + `)` または1文字、という文法規則にできる。
   - -> `factor -> "(" subexpr ")" | CHARACTER`
6. 続いて文法規則の中で単一の正規表現要素しか扱っていないのは `A*` なので、これを2番底の文法規則にできる。これは `A` だけも表現可能できる。
   - -> `star -> factor "*" | factor`
7. `AB` を考えると、これは `star` の連結と考えることができる。`star star`, `star star star`, `star star star star ...` と続くことを考えると、最初の `star` に続いて正規表現の連結が再帰的に配置される文法規則ですっきり整理できる。(この辺の詳細は元記事(3) 参照)
   - -> `subseq -> star subseq | star`
8. 最後の `A|B` については "正規表現1 | 正規表現2" または "正規表現" と考えれば、上位の文法規則として配置できる。また、ここまで空文字列を扱ってこなかったので、ここで空文字列も導入する。 `subseq` の上に、`subseq` または空文字 という文法規則 (`seq`) を置き、 `|` で `seq` を連結する。ただし `|` の右側は空文字列を許容しないので、 `subseq` とする。
   - -> `seq -> subseq | ''`
   - -> `subexpr -> seq '|' subexpr | seq`
   - -> `expression -> subexpr EOF`

上位から順に並べ押したのが以下の文法規則となる。

```
(A) expression -> subexpr EOF
(B) subexpr -> seq '|' subexpr | seq
(C) seq -> subseq | ''
(D) subseq -> star subseq | star
(E) star -> factor '*' | factor
(F) factor -> '(' subexpr ')' | CHARACTER
```

### [3-2] 必要な構文木の検討

文法規則を元に、構文木で必要となるnodeを検討する。

1. `factor` で必要となるのが、一文字を表現するnodeであり、これが全ての基本になる。
   - 空文字(ε)もこれで表す。
2. 繰り返し(`star`) を表現するnodeが必要。
   - `a*` などの文字の繰り返しに加え、`(a|b)*` など正規表現自体の繰り返しも表現する、再帰的なnodeになる。
3. 連結(`seq`, `subseq`)を表現するnodeが必要。
   - `abc` などの文字列(= 文字の連結)に加え、`a*b` や `(a|b)c` など正規表現同士の連結も表現する、再帰的なnodeになる。
4. 最後にOR(`subexpr`)を表現するnodeが必要。
   - `a|b` などの文字のORに加え、`(a|b)|(c*)` など正規表現自体のORも表現する、再帰的なnodeになる。

一文字を表現するnode以外は全て再帰的なnodeになる。

### [3-3] 構文木から生成可能なNFAの表現方法と実装

再帰的なnodeで構成されたツリー構造から何かしらのデータを構築する方法として、元の連載記事(4)では Interpreter パターンを採用している。
Interpreterパターンではツリー構造を再帰的に辿り、それぞれのnodeでのアクションを実行していく。
アクションの中で、何かしらのデータを構築し、それを永続化する。
再帰的にアクションが積み重なっていくことで、最終的なデータが完成する。

今回構築したい「何かしらのデータ」はNFAの設計図(前掲の `Nfa` クラス)となるが、ではどうすればNFAの状態遷移を Interpreter パターンのアクションの積み重ねで構築していくか？

答えは既に元の連載記事(4)で示されているものの、最初に一読したときは「なぜこれで表現できるのか？」がスッと頭に入ってこなかった。
そこで、こちらの作業ログでは元の連載記事(4)で提示されているコードについて、自分なりの解説を加えることで理解を深めてみる。

#### [3-3-1] 遷移関数をmapとして表現することの検討

NFAの構成要素:

1. 初期状態
2. 遷移関数 (状態, 入力文字) -> 遷移先の状態の集合
3. 受理可能状態の集合

遷移関数を「データ」で表現しようとするとどうなるか？
シンプルに考えれば、パラメータに対する戻り値のmap構造で表現できる。
よって Interpreter パターンではこのmap構造を生成することがメインターゲットになる。

例えば `a(b|c)` に対応するNFAは、遷移関数のmap構造として以下が考えられる:

| 現在状態 | 入力文字 | 遷移先の状態の集合 |
| ------- | --------| ------------------|
| S1      | 'a'      | [S2, S3]         |
| S2      | 'b'      | [S4]             |
| S3      | 'c'      | [S5]             |

この場合初期状態はS1, 受理可能状態は S4, S5 となる。

これを INterpreter パターンで再帰的に辿ることで構築することになる。
いきなり単一の巨大なmap構造を作る方法も考えられるが、元の連載記事 (4) では単一nodeに対応するNFAフラグメントを作成し、それを再帰的に結合していく方法を採用している。

例えば `ab` という文字連結の正規表現があるとする。
文法規則では `a` , `b` という2つの文字nodeと、それを連結したnodeのツリーに構成される。
これをそれぞれのnodeごとのNFAフラグメントとして表現したあと、それを連結してみる。

まず `a` の文字nodeに対応するNFAフラグメントを考えてみる。
これは状態S1に対して、`a` という入力文字で状態S2に遷移するNFAフラグメントとして表現できる。
(S1, S2 の具体的な中身についてはここでは考えない。前に作成した `Nfa` クラスに従うなら整数値となり、これについては後述する)

| 現在状態 | 入力文字 | 遷移先の状態の集合 |
| ------- | --------| ------------------|
| S1      | 'a'      | [S2]             |

`b` についても同様に考える。

| 現在状態 | 入力文字 | 遷移先の状態の集合 |
| ------- | --------| ------------------|
| S3      | 'b'      | [S4]             |

この2つのnode = NFAフラグメントを、連結によって単一のNFAフラグメントにマージすることを考える。
単純に遷移関数を結合しただけでは、S2 -> S3 への遷移が表現できない。
そこで、以下のように S2 -> S3 に空文字(ε)で遷移するようにする。

| 現在状態 | 入力文字 | 遷移先の状態の集合 |
| ------- | --------| ------------------|
| S1      | 'a'      | [S2]             |
| S2      | ε        | [S3]             |
| S3      | 'b'      | [S4]             |

結合後の全体のNFAとしては、初期状態は S1, 受理可能状態は S4 となる。

なお、上の例であれば `b` のNFAフラグメントを結合するさいに、`b` 入力に対応する現在状態 S3 を、`a` の遷移先状態である S2 に書き換える方法も考えられる。
上の例では受理可能状態と初期状態がそれぞれ単一のため書き換えもできなくは無いが、ORを表現するnodeや繰り返しを表現するnodeが混ざってくると処理が複雑化する。
よって、既存のNFAフラグメントのパラメータは置き換えずに、それらを空文字(ε)で結合する新たな遷移設定を追加する方法が、単純で実装しやすいものと思われる。

NFAフラグメント同士の「連結」をうまく表現できた。
元の連載記事(4)では、同様の考え方で「繰り返し」や「OR」についても表現している。
残るは「状態」をどう管理するか、となる。

#### [3-3-2] 「状態」の管理

遷移関数の実体は入力をキーとして出力を値とするmap構造であり、入力キーはuniqueを保つ必要がある。
これを実現するため、`Nfa` クラスで採用した整数値としての状態は、連番として自動採番されるのが望ましい。
Interpreter パターンにおいて、再帰的にツリーを辿る中で処理全体で一貫して管理する必要のあるパラメータは `Context` という形で引き継いでいく。
元の連載記事では `Context` クラスに状態の自動採番機能をもたせ、各nodeで新規に状態を採番するときに使うようにしている。

#### [3-3-3] 構文木に対応するnodeと Interpreter パターンの実装

ここまでの検討と理解の積み重ねにより、ようやく実装に進むことができる。

まず Interpreter パターンの再帰処理全体でパラメータを管理する `Context` クラスを作成し、それに状態の自動採番機能を実装する。

- [Context](./Context.java)

次に NFA フラグメントを表現する `NfaFragment` クラスを作成する。
これはいわば「編集可能な `Nfa` クラス」であり、遷移関数のmap構造を操作したり、map構造を結合して新たなNFAフラグメントを生成する機能を提供する。

- [NfaFragment](./NfaFragment.java)
  - `build()` メソッドにより、このNFAフラグメントを使った `Nfa` クラスのインスタンスを生成できるようにしている。

続いて構文木のnodeに対応するクラスを作成していくが、再帰的に辿るため、統一したinterfaceである `INodeAssembler` を作成し、これを実装することとする。

```java
public interface INodeAssembler {
    NfaFragment assemble(final Context context);
}
```

あるnodeが実装している `assemble()` を呼び出すと、そのnodeにぶら下がっているnodeの `assemble()` が呼び出され、さらにそれにぶら下がっている node の `assemble()` が呼び出され・・・というように再帰的に辿るイメージとなり、これが Interpreter パターンによる再帰処理を実現している。

以下が、元の連載記事(4)を参考に `INodeAssembler` を実装した各nodeクラスとなる。詳細な解説はソースコードを参照。

- [CharacterNode](./node/CharacterNode.java) : 1文字を表現するnode
- [ConcatNode](./node/ConcatNode.java) : 連結を表現するnode
- [StarNode](./node/StarNode.java) : 繰り返しを表現するnode
- [UnionNode](./node/UnionNode.java) : ORを表現するnode

ここまでで Interpreter パターンの処理で必要となる、構文木に対応する各nodeと必要なクラスを生成できた。
この後は、元の連載記事(3)に戻り字句解析と構文解析を実装する。
nodeのツリーが出来上がれば、Interperter パターンの再帰処理を呼び出すことで、最終的に1つの遷移関数に結合されたNFAが生成されることになる。

### [3-4] コンパイラの作成

#### [3-4-1] トークンの定義

まず字句解析のためのトークンを定義する。
元の連載記事 (3) に従って以下のトークン種別を Java の enum として定義する。

| トークン種別 | 説明 |
| ----------- | ---- |
| CHARACTER   | 文字を表すトークン。'a'～'z'、'あ'～'ん'、等 |
| OPE_UNION   | 和集合演算 '\|' |
| OPE_STAR    | 繰り返し演算 '*' |
| LPAREN      | 左括弧 '(' |
| RPAREN      | 右括弧 ')' |
| EOF         | 文末を表す |

実際に字句解析がトークンを取り出すときは、トークン種別 + 実際の1文字のペアになる。

-> 種別 + 1文字を保存するコンテナクラスとして、 [Token](./Token.java) クラスにまとめた。

#### [3-4-2] 字句解析(Lexer)

続いて字句解析処理を実装する。
これについては元の連載記事(3)に掲載されている Python のコードを、そのまま Java に変換して [Lexer](./Lexer.java) クラスとして作成している。

#### [3-4-3] 構文解析(Parser)

字句解析で得られたトークンを元に、構文解析を行い構文木(nodeツリー)を構築する。
今回実装する正規表現の構文は、`[3-1]` で検討した以下のrule(再掲)で解析できる。

```
(A) expression -> subexpr EOF
(B) subexpr -> seq '|' subexpr | seq
(C) seq -> subseq | ''
(D) subseq -> star subseq | star
(E) star -> factor '*' | factor
(F) factor -> '(' subexpr ')' | CHARACTER
```

字句解析と同様、元の連載記事(3) に掲載されている Python のコードをほぼそのまま Java に変換して [Parser](./Parser.java) クラスとして作成した。元のPython コードからは以下を変更している。

- `match()` メソッド名を `consume()` に変更
  - メソッドの処理としては、「期待されたトークンを消費して、次に進む」という内容になっている。そのため `match()` だけだと「次に進む」というニュアンスが読み取りづらく感じた。
  - 一方で、`forward()` だけだと「期待されたトークンでなければ例外スローしてそこで止める」というニュアンスが出てこない。
  - -> 期待されたトークンを明示し、それを消費する、というニュアンスが伝わるであろう `consume()` に変更した。
- `seq` rule の解析で、元のPythonコードでは空文字(ε)を `return Character("")` として表現していた。
  - -> Java版においては文字を `Optional<Character>` で表現しているので、空文字列(ε)を `Optional.empty()` として表現するよう変更した。

余談だが、元の連載記事だと node の各クラスの解説の前に Parser クラスの解説が置かれる。
順に読み進めているといきなり `Concat` とか `Character` など見たこと無いクラスが登場し、困惑した。
注意深く読むと、その後の(4)の連載記事で解説があるらしいことが読み取れ、そこで(4)に進んで各nodeクラスについて理解し、その後(3)に戻るとそこでようやく全貌が掴めた。
本作業ログでは、自分におけるそうした理解の進み方をなるべくそのままの流れで書いてみた次第。
自分同様の方（あるいは、この記事をすっぱり忘れた未来の自分）の一助になれば幸いです。

## [4] 連載記事(5)

元記事URL : https://codezine.jp/article/detail/3168

元の連載記事では、部分集合構成法を使ってNFAをDFAに変換する解説と実装を行っている。
こちらでは、元記事の解説をベースとしつつ、個人的に分かりづらい箇所があったのでそれを補足してみる。

NFAとDFAの違いについて、まずJavaでの表現を元に復習する。

| 定義 | NFA | DFA |
| -------------- | ----------- | ----------- |
| 状態            | 整数値(int) | 整数値(int) |
| 遷移関数(引数)   | (現在の状態, `Optional<Character>`) | (現在の状態, `Character`) |
| 遷移関数(戻り値) | 次の状態(int)の集合 = `Set<Integer>` | 次の状態(int) |
| 開始状態        | 整数値(int) | 整数値(int) |
| 受理状態の集合   | `Set<Integer>` | `Set<Integer>` |

DFAが「決定的」であるポイント(= NFAとの大きな違い):

1. 遷移関数の引数でNFAは空文字を受け付けるが、DFAは受け付けない。
2. 遷移関数の戻り値でNFAは複数の遷移先を返すが、DFAではただ一つの遷移先を返す。

上記ポイント1, 2 を満たす特性をNFAから取り出すことができれば、DFAとして扱うことが可能となる。
そこで元記事で採用されているのが「部分集合構成法(subset construction)」である。

### [4-1] 部分集合構成法(subset construction)

例として以下のようなNFAを考える。(初期状態 = S0, 受理状態集合 = {S2})

```
遷移関数の内部テーブル:
[S0, 'a'] => {S1, S2}
[S1, 'b'] => {S2}
[S2, ε] => {S0}
```

初期状態(S0)に 'a' を入力すると、S1 または S2 の状態に遷移できる。
S2だが、これはεで S0 に遷移しうる。
ということは、S2の状態に遷移できる = S2 にも、そしてS0 にも遷移できる、と考えられる。
そのため `[S0, 'a']` から遷移しうる状態は、εを排除すると　`{S0, S1, S2}` であると考えられる。

続いて仮に S1 に遷移したと仮定すると、ここで 'b' が入力されると NFA の遷移関数上は S2 に遷移する。
しかしこれも同様にεを排除することで、 `{S0, S2}` に遷移できる、と考えられる。

このように考えていくと、NFA全体としては「(εを排除した上での)次の状態の集合」が、各入力値に対してただ一つの遷移先として存在すると考えることができる。
これは上記ポイント1(εを使わない), ポイント2(遷移先が唯一つに定まる)を満たしており、この特性を表現できれば、NFAをDFAとして扱うことができる。
そのために **「(εを排除した上での)次の状態の集合」(= 部分集合)それ自体をDFAにおける1つの状態として扱う** のが、部分集合構成法のポイントになると自分は理解した。

この考え方を使って、NFAの定義(Javaでの表現)をDFA流儀に変換してみる。

- 状態:
  - NFA/DFAでは整数値で状態を表していた。
  - -> これを、「遷移可能な状態の集合」それ自体を状態として扱うことにする。
  - `int` -> `Set<Integer>`
- 遷移関数(引数):
  - NFA/DFAでは現在の状態 = 整数値だった。
  - -> これが「現在の」遷移可能な状態の集合になる。
- 遷移関数(戻り値):
  - 考え方としては、引数の「現在の遷移可能な状態の集合」のそれぞれの状態についてNFAの遷移関数を適用し、その戻り値(=NFAにおける次の状態の集合)の和集合と考えられる。
  - 言い換えると、現在から遷移可能な全ての未来の集合。
  - DFAの流儀ではεは許可しない。NFA遷移関数の戻り値の和集合においても、そこからεで遷移可能なところは全て辿った結果にマージする必要がある。
  - 戻り値としては `Set<Integer>` となる。
    - DFAとして「状態 = `Set<Integer>`」なので、DFAの遷移関数の定義に従っている。
    - 「現在から遷移可能な全ての未来の集合、それ自体が唯一つに定まる」と考えるべきか。
- 開始状態
  - NFA/DFAでは現在の状態 = 整数値だった。
  - これの開始状態をどう考えるかだが、素直に整数値の集合と考えることができる。
  - NFAにおける初期状態から空文字(ε)で遷移できる状態があれば、それも含めた集合と考える。
  - `int` -> `Set<Integer>`
- 受理状態の集合
  - これについては「べき集合」が関係してくるため、節を分けて考察する。

### [4-2] べき集合と受理可能状態の考察

NFAをDFAとして扱うために、NFAが遷移可能な状態の集合(`Set<Integer>`)、それ自体を「状態」として扱うところまで先の節で辿ってきた。
ここで「受理可能状態の集合」はどうなるか考察する。

そのまま考えると「受理可能な「遷移可能な状態の集合」の集合」(`Set<Set<Integer>>`) となり、言葉だけでは非常に分かりづらい。
そこで、まずNFAでどう考えていたかを思い出す。

例として、NFAでの遷移関数が {S2, S3, S4, S5} を返したとする。
このNFAの受理可能状態の集合が {S3, S5} だった場合、　{S2, S3, S4, S5} は受理可能と言えるか？

-> 遷移関数が返した {S2, S3, S4, S5} の意味は、「遷移した結果は S2 としてもいいし、S3としてもいいし、S4としてもいいし、S5としてもいい」と考えられる。
どれも、現在の状態 + 入力文字から遷移できる、正当な「可能性の1つ」であるからだ。
NFAが幅優先探索で実装されていれば、S2/S3/S4/S5 それぞれごとに、次の入力文字をペアにして遷移関数に与えるだろう。
受理可能状態の S3 と S5 が含まれているので、S3 または S5 として扱えば、これは受理可能状態となる。
よって {S2, S3, S4, S5} は受理可能状態であると考えることができる。

-> 「受理可能な「遷移可能な状態の集合(`Set<Integer>`)」の集合(`Set<Set<Integer>>`)」は、「「元のNFAの受理可能な状態の集合のうち、1つ以上の要素を含んだ "遷移可能な状態の集合"」の集合」と書き換えることができる。

例 : 元のNFAで S0, S1, S2 の各状態がある時に、受理可能状態の集合が {S1, S2} だとする。
これをDFAに変換すると、「「元のNFAの受理可能な状態の集合のうち、1つ以上の要素を含んだ "遷移可能な状態の集合"」の集合」は以下のようになる。

```
{
  {S1},
  {S2},
  {S0, S1},
  {S0, S2},
  {S1, S2},
  {S0, S1, S2}
}
```

この例で「受理可能でない」集合は以下の集合だけになる : `{}(空), {S0}`

では、この入れ子集合はどうやって生成できるか？
理屈で考えると、NFAをDFAに変換する過程で「遷移可能な状態の集合」のパターンを全て洗い出し、その中から元のNFAの受理可能状態の集合を含むパターンを抽出することになる。
しかし、それは考えられる全てのパターンを総当りすることであり、結果として「NFAが取りうる状態の集合のべき集合」を扱うことになる。(べき集合については 参考資料 [7] 等も参照のこと)

「NFAが取りうる状態の集合のべき集合」とは何か。
例として S0, S1, S2, S3 という状態に遷移しうるNFAを考えてみる。
DFAに変換する場合、{S0, S1, S2, S3} の中から様々な組み合わせパターンでDFAとしての「状態」が出てくる。
これは集合 {S0, S1, S2, S3} に対してその部分集合を全て集めた集合であり、数学的には「べき集合」と呼ばれるものになり、要素の数は元の集合の要素数で2をべき乗したものになる。
先の例 {S0, S1, S2} ではパターン数は 8 (2の3乗) となったが、例 {S0, S1, S2, S3} でのパターン数は16 (2の4乗)となる。

```
{}, {S0}, {S1}, {S2}, {S3},
{S0, S1}, {S0, S2}, {S0, S3},
{S1, S2}, {S1, S3}, {S2, S3},
{S0, S1, S2}, {S0, S1, S3}, {S0, S2, S3}, {S1, S2, S3}, 
{S0, S1, S2, S3}
```

元のNFAの受理可能な状態の集合を {S2, S3} とすると、この内1つ以上を含む集合を上記の16パターンから抽出する。

```
{S2}, {S3},
{S0, S2}, {S0, S3},
{S1, S2}, {S1, S3}, {S2, S3},
{S0, S1, S2}, {S0, S1, S3}, {S0, S2, S3}, {S1, S2, S3}, 
{S0, S1, S2, S3}
```

これが元のNFAをDFAに変換したときの「受理可能な「遷移可能な状態の集合」の集合」(`Set<Set<Integer>>`)となる。

### [4-3] 受理可能状態の計算量への対処

ここまでの NFA -> DFA 変換をまとめると、各定義は以下のように整理できる。

| 定義 | NFA | NFA -> DFA |
| -------------- | ----------- | ----------- |
| 状態            | 整数値(int) | 整数値(int) **の集合** = `Set<Integer>`  |
| 遷移関数(引数)   | (現在の状態, `Optional<Character>`) | (現在の状態 **の集合** = `Set<Integer>` , `Character`) |
| 遷移関数(戻り値) | 次の状態(int)の集合 = `Set<Integer>` | 次の状態(int) **の集合**  = `Set<Integer>` |
| 開始状態        | 整数値(int) | 整数値(int) **の集合**  = `Set<Integer>` |
| 受理状態の集合   | `Set<Integer>` | 整数値(int) **の集合の集合**  = `Set<Set<Integer>>` |

ここで受理可能状態の集合の生成方法が問題となってくる。
なぜなら、これを厳密に生成しようとすると元のNFAが取りうる状態の集合のべき集合をまず生成する必要があるが、これが2のべき乗の要素数となり、幾何級数的に生成する部分集合が増えていってしまう。
そこでこれについて最適化を考えてみる。

もともとこれでやりたいことは、受理可能か判定したい「状態の集合(`Set<Integer>`)」の中に、元のNFAの受理可能な状態集合の要素が1つ以上含まれているかどうか？という判定だった(1つ以上含まれているなら、受理可能とみなせる)。
これは「検査対象の状態集合」と「元のNFAの受理可能な状態集合」の積集合を取り、空でなければ受理可能、空になれば受理できない、と書き直すことができる。

-> 事前にべき集合を生成する必要はなくなり、元のNFAの受理可能状態の集合をそのまま流用して、判定処理を積集合の計算とその内容の判定に書き換えれば、やりたいことが実現できる。

上記の考察を元に修正したのが以下のマッピングであり、これを使って Java の実装を進める。

| 定義 | NFA | NFA -> DFA |
| -------------- | ----------- | ----------- |
| 状態            | 整数値(int) | 整数値(int) **の集合** = `Set<Integer>`  |
| 遷移関数(引数)   | (現在の状態, `Optional<Character>`) | (現在の状態 **の集合** = `Set<Integer>` , `Character`) |
| 遷移関数(戻り値) | 次の状態(int)の集合 = `Set<Integer>` | 次の状態(int) **の集合**  = `Set<Integer>` |
| 開始状態        | 整数値(int) | 整数値(int) **の集合**  = `Set<Integer>` |
| 受理状態の集合   | `Set<Integer>` | `Set<Integer>` **(元のNFAと同じ)** |

### [4-4] Javaでの実装

#### [4-4-1] 空文字(ε)遷移の展開メソッド

`NFA -> DFA` の開始状態および遷移関数の戻り値について、元のNFAの遷移関数から空文字(ε)で遷移する状態をマージする必要がある。
これによりDFAの特徴である、空文字(ε)遷移の排除を実現する。
そのため [Nfaクラス](./Nfa.java) に以下のメソッドを追加した。

```java
    public Set<Integer> expandEpsilon(Set<Integer> states) {
        Queue<Integer> queue = new ArrayDeque<>(states);
        Set<Integer> done = new HashSet<>();
        while (!queue.isEmpty()) {
            final int state = queue.remove();
            final Set<Integer> nextStates = this.transition.apply(state, Optional.empty());
            done.add(state);
            for (int nextState : nextStates) {
                if (!done.contains(nextState)) {
                    queue.add(nextState);
                }
            }
        }
        return Collections.unmodifiableSet(done);
    }
```

これは元の連載記事の Python コード `epsilon_expand()` をほぼそのままJavaに書き直したものとなる。
(細かいコメントについてはソースコードを参照)

#### [4-4-2] NFA -> DFA 用のDFAを実装

最初の頃に [Dfaクラス](./Dfa.java) を作ったが、これは状態を整数値として決め打ちした Java コードになっている。
素直に考えればジェネリクスを導入して `Dfa<Integer>` とし、NFA -> DFA については `Dfa<Set<Integer>>` とできればスマートである。
ところが `[4-3]` 節で受理可能状態の集合を最適化したため、`Set<T> -> Set<Set<Integer>>` とはできない。
よってジェネリクスを導入して Dfa クラスを汎用化することは諦め、NFA -> DFA 変換専用のクラス群として以下を作成した。

1. [Nfa2DfaStateTransitFunction 関数型インターフェイス](./Nfa2DfaStateTransitFunction.java)
   - まず専用の遷移関数を関数型インターフェイスとして用意。
   - 引数と戻り値について、NFA -> DFAで整理した定義に基づいて素直に実装してみた。
2. [Nfa2Dfaクラス](./Nfa2Dfa.java)
   - NFA -> DFA に変換した際のパラメータを保持する。
   - これも NFA -> DFA で整理した定義に基づいて素直に実装してみた。
3. [Nfa2DfaRuntime クラス](./Nfa2DfaRuntime.java)
   - DFAで作成した [DfaRuntime クラス](./DfaRuntime.java) を流用(コピー)して作成。
   - `isCurrentStatusAcceptable()` の実装を NFA -> DFA変換で最適化した判定処理に変更している。
   - Java の Set で積集合を扱う参考として、参考資料 [11] を参照。

ここまで来れば、NFA -> DFAの変換を実装できる。
肝心の NFA -> DFA の遷移関数は以下のように実装できる。

1. 引数で渡された「現在の状態の集合」それぞれに対して元のNFAの遷移関数で「次の状態の集合」を求める。
2. それらの和集合を構築したら、空文字(ε)遷移可能な状態も抽出し、マージしたのを戻り値とする。

-> [Nfa クラス](./Nfa.java) を引数で受け取る static ファクトリメソッドを[Nfa2Dfa クラス](./Nfa2Dfa.java) に 追加し、以下のように変換処理を実装した。

```java
public class Nfa2Dfa {
    // ...
    public static Nfa2Dfa from(final Nfa nfa) {
        final Nfa2DfaStateTransitFunction transition0 = (
                final Set<Integer> setOfCurrentState,
                final char character) -> {
            final Set<Integer> setOfNextState = new HashSet<>();
            for (int currentState : setOfCurrentState) {
                final Set<Integer> nfaResult = nfa.transition.apply(currentState, Optional.of(character));
                setOfNextState.addAll(nfaResult);
            }
            return nfa.expandEpsilon(setOfNextState);
        };
        // 元のNFAの初期状態から空文字(ε)遷移可能な状態も集約した集合を初期状態とする。
        final Set<Integer> setOfInitialState = nfa.expandEpsilon(Set.of(nfa.start));
        // 受理可能状態についてはパフォーマンスを考慮して元のNFAの受理可能状態の集合をそのまま使う。
        return Nfa2Dfa.of(transition0, setOfInitialState, nfa.accept);
    }
}
```

#### [4-4-3] クライアントAPIの作成

ここまでのコードを統合すれば、正規表現のコンパイルと文字列マッチのクライアント向けAPIを作成できる。

正規表現コンパイルの流れ:

```java
Lexer lex = new Lexer("(a|b)*cd*e|f");
Parser parser = new Parser(lex);
Nfa nfa = parser.expression();
Nfa2Dfa nfa2dfa = Nfa2Dfa.from(nfa);
```

コンパイル結果を元に文字列マッチの流れ:

```java
Nfa2DfaRuntime runtime = new Nfa2DfaRuntime(nfa2dfa);
return runtime.accept("aaaacdddde");
// -> マッチ結果を boolean で返す。
```

上記をクラスにまとめ、簡単なテストコードとして使い方のサンプルを示したのが以下のコードになる。

- [Regexp クラス](./Regexp.java)
  - クライアントAPI用のクラス。
- [RegexpTest クラス](./RegexpTest.java)
  - クライアントAPIのテストコードとして、使い方のサンプルを例示。

## [5] 連載記事(6)

元記事URL : https://codezine.jp/article/detail/3188

元の連載記事 (6) では、作成したDFAエンジンを使って以下の実験をしている。

1. DFAエンジンの内部構造をダンプして、動作状況を確認
2. 標準ライブラリ(元の連載記事は Python なので `re` モジュール)とのベンチマーク
3. NFAエンジンのパフォーマンス

こちらでも Java 版で同様の実験を行った。

### [5-1] DFAエンジンの内部構造をダンプして、動作状況を確認

ダンプ用のコードについては記事中では掲載されていない。
そのため、(6)からダウンロードしたサンプルコードを確認し、Java版に変換したのが以下のクラスになる。

- [NfaDumper](./NfaDumper.java)
- [Nfa2DfaDumper](./Nfa2DfaDumper.java)
- この他にもデバッグダンプ用に以下のクラスを調整している:
  - [Nfa2Dfa.from()](./Nfa2Dfa.java) -> トレースログフラグを引数に追加し、遷移関数が呼ばれた時に引数と戻り値を `System.out.println()`
  - [NfaFragment.toString()](./NfaFragment.java) -> NFAフラグメントの段階で内部構造をダンプする処理を実装

`Regexp` クラスにもダンプ用のオプションを追加し、テストコード中でダンプ出力を確認する。

[ArticleNo6DemoTest.testDebugDump()](./ArticleNo6DemoTest.java) :

```java
System.out.println(">>>> debug dump demo for https://codezine.jp/article/detail/3188");

Regexp r = Regexp.compileNfa2Dfa("XY*Z", RegexpOption.DEBUG_LOG);
System.out.println("------------------");
assertTrue(r.match("XYYYZ"));
System.out.println("------------------");
assertFalse(r.match("XYZYZYZ"));

System.out.println("<<<<");
```

出力結果:

```
>>>> debug dump demo for https://codezine.jp/article/detail/3188
----[NFA Fragment]----
initial state = 1
[ 1, 'X' -> [2] ]
[ 2, (ε) -> [5] ]
[ 3, 'Y' -> [4] ]
[ 4, (ε) -> [3, 6] ]
[ 5, (ε) -> [3, 6] ]
[ 6, 'Z' -> [7] ]
set of acceptable state = [7]

dump NFA....
start-state: 1
    'X' -> 2
state: 2
    (ε) -> 5
state: 5
    (ε) -> 3
    (ε) -> 6
state: 3
    'Y' -> 4
state: 6
    'Z' -> 7
state: 4
    (ε) -> 3
    (ε) -> 6
acceptable-state: 7

dump NFA2DFA...
start-state: [1]
    'X' -> [2, 3, 5, 6]
state: [2, 3, 5, 6]
    'Y' -> [3, 4, 6]
    'Z' -> [7]
state: [3, 4, 6]
    'Y' -> [3, 4, 6]
    'Z' -> [7]
acceptable-state: [7]
acceptable-state: [7]

NFA2DFA: setOfInitialState=[1], setOfAcceptableState=[7]
------------------
NFA2DFA TRANSITION: ([1], 'X') => [2, 3, 5, 6]
NFA2DFA TRANSITION: ([2, 3, 5, 6], 'Y') => [3, 4, 6]
NFA2DFA TRANSITION: ([3, 4, 6], 'Y') => [3, 4, 6]
NFA2DFA TRANSITION: ([3, 4, 6], 'Y') => [3, 4, 6]
NFA2DFA TRANSITION: ([3, 4, 6], 'Z') => [7]
------------------
NFA2DFA TRANSITION: ([1], 'X') => [2, 3, 5, 6]
NFA2DFA TRANSITION: ([2, 3, 5, 6], 'Y') => [3, 4, 6]
NFA2DFA TRANSITION: ([3, 4, 6], 'Z') => [7]
NFA2DFA TRANSITION: ([7], 'Y') => []
NFA2DFA TRANSITION: ([], 'Z') => []
NFA2DFA TRANSITION: ([], 'Y') => []
NFA2DFA TRANSITION: ([], 'Z') => []
<<<<
```

内容としては、元の連載記事(6)に掲載されている結果と同様になっていることを確認できた。

### [5-2] java.util.regex とのベンチマーク

元の連載記事(6)では Python の標準モジュール `re` を使って `"(f|F)(o|O)(o|O)"` という正規表現についてベンチマーク比較をしている。
今回は Java で実装しているので、 `java.util.regex` パッケージの `Pattern` と `Matcher` クラスを使って比較してみる。

- `java.util.regex`
  - https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/regex/package-summary.html
  - -> [NFAベースのマッチングを行っていると明記](https://docs.oracle.com/javase/jp/11/docs/api/java.base/java/util/regex/Pattern.html) されている。

[ArticleNo6DemoTest.testBenchmarkDemo()](./ArticleNo6DemoTest.java) で同様のベンチマークコードを作成し、実行してみた。

```
>>>> benchmark demo for https://codezine.jp/article/detail/3188?p=2
NFA2DFA v.s. java.util.regex for regexp=[(f|F)(o|O)(o|O)], match to=[FoO]
[NFA2DFA total nanos= 42,645,002 ]
[java.util.regex total nanos= 10,103,912 ]
<<<<
```

-> 元の連載記事(6)と同様、標準ライブラリの方が高速で実行されている様子を確認できた。

元の連載記事(6)ではDFAの遷移関数についてメモ化(memoize)を行い、キャッシュを導入した結果も比較している。
Java版の遷移関数でもキャッシュを導入し、キャッシュ有無でのベンチマークを比較してみた。

[ArticleNo6DemoTest.testBenchmarkDemoCacheOnOff()](./ArticleNo6DemoTest.java) 実行結果:

```
>>>> benchmark demo for https://codezine.jp/article/detail/3188?p=2
NFA2DFA(cache-off) v.s. NFA2DFA(cache-on) for regexp=[(f|F)(o|O)(o|O)], match to=[FoO]
[NFA2DFA(cache-off) total nanos= 12,969,392 ]
[NFA2DFA(cache-on ) total nanos= 5,477,783 ]
<<<<
```

キャッシュONにより、OFF時と比べて50%近く高速に動作していることを確認できた。

### [5-3] NFAエンジンのパフォーマンス

続いて元の連載記事(6)では `"X*X*X*X*X*X*X*X*X*X*XXXXXXXXXX"` という正規表現について、DFA / 標準モジュール `re` のそれぞれで `"XXXXXXXXXX"` に対して1,000回マッチさせている。
その結果、記事の方では DFA の方が `re` より8倍早く処理が終わっている。

このパターンについて Java 版でも同様に実験してみる。
NFA2DFAについてはキャッシュON/OFFの2パターンを含めてみた。

[ArticleNo6DemoTest.testBenchmarkHeavyDemo()](./ArticleNo6DemoTest.java) 実行結果:

```
>>>> benchmark demo for https://codezine.jp/article/detail/3188?p=2
NFA2DFA v.s. java.util.regex for regexp=[X*X*X*X*X*X*X*X*X*X*XXXXXXXXXX], match to=[XXXXXXXXXX]
[NFA2DFA(cache-off) total nanos= 233,900,915 ]
[NFA2DFA(cache-on ) total nanos= 32,331,078 ]
[java.util.regex total nanos= 22,219,900 ]
<<<<
```

Java11での実行結果を見る限りは、やはり `java.util.regex` の方が早い。
NFA2DFAはキャッシュONにしてなんとか `java.util.regex` のオーダーに近づけたくらい。

元の連載記事(6)では、ここで NFAエンジンのC言語実装を紹介し、ビルド～実行時の様子のトレース結果を確認している。
それによるとNFAでは繰り返しの `*` で条件分岐が発生し、その探索で処理が遅くなる。
問題の正規表現では複数の繰返しのマッチングで条件分岐が爆発し、それにより DFAエンジンより遅くなったことが解説されている。

Javaの場合はNFAであっても内部的にチューニングが積み重ねられており、そのおかげで高速に動作していることが推測できる。

## [6] NRAランタイムの実装とベンチマーク

元の連載記事(6) からDLできるサンプルコードには `dfareg/nfa.py` としてNFAのランタイムが収録されている。
元の連載記事では特に言及されていないが、[著者のblogサイト](https://hiratara.hatenadiary.jp/entry/20081203/1228320654)では簡単な解説も書かれている。

`nfa.py` には以下の2種類のNFAランタイムが含まれている。
- 幅優先 : 選択しうる状態を集合とし、全ての可能性を保持しつつマッチするまで広げて行く
  - -> 「選択可能な状態の集合」を扱うため、DFAの処理に近い実装コードとなっている。
- 深さ優先 : 選択肢を適当に選んで失敗するまで潜り、失敗したら戻って別の選択肢をやり直す (バックトラック)

これらを Java コードに変換してみたのが以下の2クラスになる。

- [NfaRuntime](./NfaRuntime.java) : 幅優先
- [NfaBackTrackRuntime](./NfaBackTrackRuntime.java) : 深さ優先
  - オリジナルの `nfa.py` では無駄なバックトラックをスキップする最適化が組み込まれていた。
  - 最初それに気づかずに実装し、後述の `(a|a)*` や `(a*)*` などでベンチマークをしても処理時間は線形増加するばかりだった。
  - バックトラックのトレースログなどを仕込んで見直していくうちに、上述の最適化処理に気づくことができ、そのON/OFFフラグを追加実装することで `O(2^N)` や `O(N^2)` 相当の遅延を発生させることに成功した。

また [Regexp.compileNfa()](./Regexp.java) で次のオプション引数を追加した。

- `RegexpOption.NFA_BACKTRACK`
  - 未指定時(デフォルト)は幅優先の `NfaRuntime` を使用。
  - 指定時は深さ優先の `NfaBackTrackRuntime` を使用。
- `RegexpOption.DISABLE_NFA_TRACED_BACKTRACK_SKIPPING` ( `RegexpOption.NFA_BACKTRACK` との組み合わせ )
  - 未指定時(デフォルト)は、バックトラックの分岐を処理する際に、一度トレースした分岐を除外する最適化処理を行う。
  - 指定時は、上記処理を行わない。このON/OFFの違いとその影響についての詳細は後述。

### [6-1] ベンチマーク1(線形増加)

ここで実際にバックトラックが発生するNFAランタイムでどの程度パフォーマンス差が出るか、ベンチマークを計測してみた。
ベンチマーク対象の正規表現として、正規表現DoS(ReDoS)の典型例である以下の3パターンを採用した。

1. `(a|a)*` (EDA用 : 後述)
2. `(a*)*` (EDA用 : 後述)
3. `a*a*`  (IDA用 : 後述)

ReDoSの問題はセキュリティ問題として研究が進んでおり、参考資料[12], [13], [14], [15]を始めとして論文やチェックツールなども公開されている。
ReDoSが発生しうる状態遷移のパターンとして、以下の2種類がある。
**これらのパターンが、なぜ `O(2^N)` や `O(N^2)` で時間がかかるかについては後述する。**

1. EDA : Exponential Degree of Ambiguity
   - `O(2^N)` などの指数計算時間がかかるパターン。
   - 例: `(a|a)*`, `(a*)*`
   - 問題となる文字列例: "aaa...ab"
2. IDA : Infinite Degree of Amgibuity
   - "infinite degree polynomial" という表現もある。
   - `O(n^2)` など多項式計算時間がかかるパターン。
   - 例: `a*a*`
   - 問題となる文字列例: "aaa...ab"

NFA2DFA(cache-off), NFA2DFA(cache-on), NFA(幅優先), NFA(深さ優先:バックトラック), `java.util.regex` の5種類で "ab", "aab", "aaab", "aaa...b" と増やしていき、経過時間をCSV出力するテストコードを作成した。

- [NfaBackTrackPerformanceDemoTest](./NfaBackTrackPerformanceDemoTest.java)

これで `MAX_LENGTH = 60` (aが1文字 - 60文字まで)のマッチ時間を計測した結果が、以下のスプレッドシートとなる。

- [2021-01-04, NFA,NFA2DFA benchmark sample](https://docs.google.com/spreadsheets/d/1-2ZI7WqUyl_cMQMQRsGVI5dYgBUt1crHyuh_2JTsEwk/edit?usp=sharing)

実行環境:

```
OS : Windows 10 Pro 64bit(1909)
CPU : Intel Core i7-10510U 1.80GHz -2.30GHz
Memory: 16GB
Java : AdoptOpenJDK(HotSpotVM) 11.0.7+10
```

結果として、今回の計測では指数関数的、あるいは多項式計算時間的なパフォーマンスの劣化は確認できなかった。
いずれのエンジンについても、1文字 - 60文字の範囲でマッチ時間は線形に増加しているように見える。
全体傾向としては深さ優先(バックトラック)NFAがパフォーマンスが引く傾向があるものの、これも線形増加に収まっている。

### [6-2] バックトラックにより極端に性能低下が発生する仕組み

ベンチマーク1では、期待していたような性能低下は発生せず全体的に `O(N)` に従う線形増加傾向となった。
その原因を探すため、まずはバックトラックが発生したときや分岐点を保存する際にトレースログを出力するよう調整し、上記パターンで10文字程度の"a..."でマッチさせるテストコードを作成してみた。
なおこの時点では `RegexpOption.DISABLE_NFA_TRACED_BACKTRACK_SKIPPING` は未使用。
つまり元の `nfa.py` に組み込まれていた最適化処理に気づいていなかった。

- [NfaBackTrackTraceDemoTest](./NfaBackTrackTraceDemoTest.java)

実行してみたところ、例えば `(a|a)*` に対して `aaab` をマッチさせると以下のようにバックトラックが発生していることがわかってきた。
(説明しやすくなるよう、実際の状態遷移から若干変形・省略しています。)

1. 1文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。この時 [左辺分岐, 残り文字列 `aab`] はトレース済みとしてマークする。(m1)
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `aab`] のペアでキューに追加する。(b1)
2. 2文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。この時 [左辺分岐, 残り文字列 `ab`] はトレース済みとしてマークする。(m2)
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `ab`] のペアでキューに追加する。(b2)
3. 3文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。この時 [左辺分岐, 残り文字列 `b`] はトレース済みとしてマークする。(m3)
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `b`] のペアでキューに追加する。(b3)
4. 4文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b1) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `aab` のマッチングを開始したのと同様な状態になる。
5. 1文字目の a について a | a で2つに分岐する。
   - オリジナルの `nfa.py` では、ここで [左辺分岐, 残り文字列 `ab`] の組み合わせを **(m2) でトレース済みとしてスキップする。**
   - よって、残った [右辺分岐, 残り文字列 `ab`] で進むことになる。
   - 他の分岐は無いため、新たなバックトラック用分岐ポイントのキュー追加は発生しない。
6. 2文字目の a について a | a で2つに分岐する。
   - オリジナルの `nfa.py` では、ここで [左辺分岐, 残り文字列 `b`] の組み合わせを **(m3) でトレース済みとしてスキップする。**
   - よって、残った [右辺分岐, 残り文字列 `b`] で進むことになる。
   - 他の分岐は無いため、新たなバックトラック用分岐ポイントのキュー追加は発生しない。
7. 3文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b2) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `ab` のマッチングを開始したのと同様な状態になる。
8. 1文字目の a について a | a で2つに分岐する。
   - オリジナルの `nfa.py` では、ここで [左辺分岐, 残り文字列 `b`] の組み合わせを **(m3) でトレース済みとしてスキップする。**
   - よって、残った [右辺分岐, 残り文字列 `b`] で進むことになる。
   - 他の分岐は無いため、新たなバックトラック用分岐ポイントのキュー追加は発生しない。
9. 2文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b3) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `b` のマッチングを開始したのと同様な状態になる。
10. 1文字目の b だが遷移先が無いため、マッチ失敗となる。
   - **バックトラック用の分岐ポイントのキューが空になったため、これ以上戻れない = 受理できない = マッチしないと判定して終了。**

もう少し簡単にまとめると、以下のように進んでいる。

1. まず左分岐で最後まで読み進め、右分岐についてはバックトラック用のキューに入れておく。
2. 最後の 'b' がマッチしないためバックトラックが発生し、最初の右分岐まで戻る。
3. そこから1文字減った状態で新しくマッチングが開始されるが、この時の左分岐が 1. でトレース済み状態なのでスキップされ、右分岐に進む。
4. 右分岐に進んだ先でも左右に分岐するが、左分岐がやはり 1. でトレース済みとしてスキップし、右分岐に進む。
5. ... 以降、左分岐は必ず 1. でトレース済みとしてスキップされ、右分岐にしか進まない。

もしこの進め方で N 文字が入力されたとすると、処理ステップは全体として 2N のオーダーで計算できることになる。
**つまり計算量は O(N) のオーダーで収まることになり、ベンチマーク1の結果と一致する。**

ポイントは「トレース済み分岐のスキップ」であり、元の `nfa.py` では `NFABacktrackRuntime` クラスの以下の処理にあたる。

```python
    def do_transition(self):
        # (...)
        # すでに辿った道を除く
        branches = set( filter(lambda x: x not in self.done, branches) )
        # (...)
```

Java 版コードでも同様に実装している。
**試しに上記処理をコメントアウトしてベンチマークを動かしてみたところ、見事に `O(2^N)` での性能低下が発生した。**
そこで、新たなフラグを導入してこの最適化処理をON/OFFできるようにし、その上で `(a|a)*` や `(a*)*`, `a*a*` のバックトラックをトレースしてみた。
その結果、これらの正規表現でバックトラックが発生するのが `O(2^N)` や `O(N^2)` になることを説明できることがわかった。

以下、それぞれの正規表現について解説する。

#### [6-2-1] `(a|a)*` が `O(2^N)` の計算量になる仕組み(EDA)

トレース済み分岐のスキップが発生しない時、 `(a|a)*` に対して `aaab` をマッチさせると以下のようにバックトラックが動く。
(説明しやすくなるよう、実際の状態遷移から若干変形・省略しています。)

1. 1文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `aab`] のペアでキューに追加する。(b1)
2. 2文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `ab`] のペアでキューに追加する。(b2)
3. 3文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `b`] のペアでキューに追加する。(b3)
4. 4文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b1) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `aab` のマッチングを開始したのと同様な状態になる。
5. 1文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `ab`] のペアでキューに追加する。(b4)
6. 2文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `b`] のペアでキューに追加する。(b5)
7. 3文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b2) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `ab` のマッチングを開始したのと同様な状態になる。
8. 1文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `b`] のペアでキューに追加する。(b6)
9. 2文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b3) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `b` のマッチングを開始したのと同様な状態になる。
10. 1文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b4) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `ab` のマッチングを開始したのと同様な状態になる。
11. 1文字目の a について a | a で2つに分岐する。
   - 左辺の a 分岐で一旦進む。
   - 右辺の a 分岐は [右辺分岐, 残り文字列 `b`] のペアでキューに追加する。(b7)
12. 2文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b5) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `b` のマッチングを開始したのと同様な状態になる。
13. 1文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b6) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `b` のマッチングを開始したのと同様な状態になる。
14. 1文字目の b だが遷移先が無いため、マッチ失敗となる。
   - バックトラックが発生し、キューから取り出した (b7) 分岐まで戻る。
   - これにより、`(a|a)*` に対して `b` のマッチングを開始したのと同様な状態になる。
15. 1文字目の b だが遷移先が無いため、マッチ失敗となる。
   - **バックトラック用の分岐ポイントのキューが空になったため、これ以上戻れない = 受理できない = マッチしないと判定して終了。**

もう少し簡単にまとめると、以下のように進んでいる。

1. まず左分岐で最後まで読み進め、右分岐についてはバックトラック用のキューに入れておく。
2. 最後の 'b' がマッチしないためバックトラックが発生し、最初の右分岐まで戻る。
3. そこから1文字減った状態で新しくマッチングが開始され、これもまずは左分岐で最後まで読み進め、右分岐についてはバックトラック用のキューに入れていく。
4. ... 以降、分岐は必ず両方たどることになる。

もしこの進め方で N 文字が入力されたとすると、1文字目で2つに分岐、2文字目で2 x 2 で4つに分岐、3文字目で 4 x 2 で8つに分岐, ... となり、処理ステップは全体として 2^N  のオーダーで計算できることになる。
**つまり計算量は O(2^N) のオーダーで発散することになり、EDA : Exponential Degree of Ambiguity の文字通り指数関数的に増えていくことになる。**

#### [6-2-2] `(a*)*` が `O(2^N)` の計算量になる仕組み(EDA)

`(a*)*` はNFAの初期状態, 遷移関数, 受理可能状態の集合が次のように構成される。

- 初期状態 : S1
- 遷移関数:
  - S1, (ε) -> {S2}
  - S2, (ε) -> {S2, S3}
  - S3, 'a' -> {S4}
  - S4, (ε) -> {S2, S3}
- 受理可能状態の集合: { S1, S2, S4 }

ここで初期状態S1からの遷移を考えると、空文字(ε) で S2, S2 から空文字(ε)で S2, S3 に分岐する。
S3 からは 'a' の遷移があり、全体としては空文字(ε)と'a'での分岐が発生することになる。
**つまり状態遷移に分岐が潜んでおり、`(a|a)*` と同様にバックトラックによる分岐の総当りが O(2^N) で発生する。**

#### [6-2-3] `a*a*` が `O(N^2)` の計算量になる仕組み(IDA)

`a*a*` はNFAの初期状態, 遷移関数, 受理可能状態の集合が次のように構成される。

- 初期状態 : S1
- 遷移関数:
  - S1, (ε) -> {S2, S4}
  - S2, 'a' -> {S3}
  - S3, (ε) -> {S2, S4}
  - S4, (ε) -> {S5}
  - S5, 'a' -> {S6}
  - S6, (ε) -> {S5}
- 受理可能状態の集合: { S4, S6 }

ここで初期状態S1からの遷移を考えると、空文字(ε) で S2, S4 に分岐する。
S2 からは 'a' の遷移が、S4からは空文字(ε)で接続されS5になり、S5からも 'a' の遷移がある。
つまり状態遷移に分岐が潜んでいるわけだが、実際にバックトラックの様子をトレースしてみると `(a|a)*` や `(a*)*` とは異なる動きになる。

例として `aaa...ab` と 'a' が N 文字続くケースでは以下のように動作する。

1. 最初の `a*` : 1文字ずつN文字マッチしていく。
   - 都度、次の `a*` のための分岐が保存される (b1, b2, ... bN-1)
   - bでマッチ失敗して、バックトラック発生(b1)
2. 戻ってきた分岐 b1 は次の `a*` のマッチで始まる。(最初の `a*` は1文字目のa でマッチが終わった状態。)
   - `a*` 1ペアでのマッチなので、新たな分岐は発生せず、 1文字ずつ N-1 文字マッチしていく。
   - bでマッチ失敗して、バックトラック発生(b2)
3. 戻ってきた分岐 b2 は次の `a*` のマッチで始まる。
   - `a*` 1ペアでのマッチなので、新たな分岐は発生せず、 1文字ずつ N-2 文字マッチしていく。
   - bでマッチ失敗して、バックトラック発生(b3)
4. 戻ってきた分岐 b3 は次の `a*` のマッチで始まる。
   - `a*` 1ペアでのマッチなので、新たな分岐は発生せず、 1文字ずつ N-3 文字マッチしていく。
   - bでマッチ失敗して、バックトラック発生(b4)
5. 戻ってきた分岐 b4 は次の `a*` のマッチで始まる。
   - `a*` 1ペアでのマッチなので、新たな分岐は発生せず、 1文字ずつ N-4 文字マッチしていく。
   - bでマッチ失敗して、バックトラック発生(b5)
6. (...)

マッチする文字数が N, N-1, N-2, N-3, ... とバックトラック毎に少なくなっていくため、全体のマッチ文字数としては `N * N / 2` となる。
**よって `a*a*` は O(N^2) の計算量で発散する。**
これが IDA : Infinite Degree of Amgibuity に分類されるパターンであり、 "polynomial time" あるいは多項式計算時間がかかるパターンとも言われている。

ただし、トレース済み分岐のスキップを有効化するとなぜ `O(N)` の計算量になるのかについては、自分の理解不足で現時点では説明できない。

### [6-3] ベンチマーク2 : `O(2^N)`, `O(N^2)` で発散

(TODO)
NfaBackTrackPerformanceDemoTest から `RegexpOption.DISABLE_NFA_TRACED_BACKTRACK_SKIPPING` を分ける。

## まとめと感想

### まとめ

- CodeZine連載「正規表現エンジンを作ろう」のPythonサンプルコードを Java に変換し、実際に正規表現マッチを動かすことに成功した。
- 元の連載記事に対して補足説明を試み、「なぜそうなるのか」というところを自分が理解した範囲でじっくり追いかけ、理解を深めることができた。
- Javaに変換する際はテストコードを作成するようにした。これは不注意に基づくバグの混入を避けるのに貢献したものと思われる。
- (TODO) サンプルコード中の深さ優先(バックトラック)NFAランタイムを検証してみたところ、ReDoSを起こすようなケースでも処理時間は線形増加にとどまり、DoS相当の状況を確認できなかった。

### 感想

(TODO)

## 参考資料

記事中で参照されている参考資料からショートカットとして抜粋、および自身で探して見つかった資料集。

正規表現の全般的な参考資料としては [NOTE.md](../NOTE.md) 参照。 

著者のblogサイトより、公開当時の宣伝&補足解説記事:

- (1) : https://hiratara.hatenadiary.jp/entry/20081105/1225867216
- (2) : https://hiratara.hatenadiary.jp/entry/20081112/1226494278
- (3) : https://hiratara.hatenadiary.jp/entry/20081119/1227076587
- (4) : https://hiratara.hatenadiary.jp/entry/20081126/1227677392
- (5) : https://hiratara.hatenadiary.jp/entry/20081203/1228320654
- (6) : https://hiratara.hatenadiary.jp/entry/20081210/1228925761

連載記事(1) より

- [1] `計算理論の基礎`, Michael Sipser 著、渡辺治・太田和夫 訳、共立出版、2000年4月
  - https://www.amazon.co.jp/exec/obidos/ASIN/4320029488/secodezine-22/
  - 原著は `Introduction to the Theory of Computation`, https://www.amazon.co.jp/dp/113318779X
- [2] `Regular Expression Matching Can Be Simple And Fast`, Russ Cox, January 2007
  - https://swtch.com/~rsc/regexp/regexp1.html

連載記事(3) より

- [3] `Compilers Principles, Techniques, & Tools`, Alfred V. Aho Monica S. Lam Ravi Sethi Jeffrey D. Ullman 著、Addison-Wesley、2007年10月
  - https://www.amazon.co.jp/exec/obidos/ASIN/0321547985/secodezine-22/

Interpreter パターン

- [4] `Interpreter パターン - Wikipedia`
  - https://ja.wikipedia.org/wiki/Interpreter_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3
- [5] `デザインパターン ～Interpreter～ - Qiita`
  - https://qiita.com/i-tanaka730/items/adf5090cdbfd55cbc9b5
- [6] `23．Interpreter パターン | TECHSCORE(テックスコア)`
  - https://www.techscore.com/tech/DesignPattern/Interpreter.html/

べき集合

- [7] `べき集合の意味と要素数 - 具体例で学ぶ数学`
  - https://mathwords.net/bekisyugou

部分集合構成法による NFA -> DFA 変換の参考資料

- [8] `部分集合構成法 - ゆるやかなぼっち`
  - http://yumura-s.hatenablog.com/entry/2013/12/26/080454
- [9] `計算の理論 I NFAとDFAの等価性`
  - https://www.cs.is.saga-u.ac.jp/lecture/automaton/03F/Lect04.pdf
- [10] `第 10 講 DFA と NFA (林　恒俊)`
  - http://www.eonet.ne.jp/~tktkhaya/flaa_files/L&A-10.pdf
- 自分の場合、元の連載記事だけでは理解出来なかったため、いろいろググってみて上記の資料を見比べながら、ようやく理解した気分になれました。

Java のコレクションAPIでの集合処理参考

- [11] `Javaによる集合演算（そしてequalsとhashCodeの理解）のススメ - Qiita`
  - https://qiita.com/SierSetup/items/97b13d78fa11b4483b09

正規表現DoS (ReDoS) 関連資料:

- [12] `[Z-Ⅲ] ReDoSの検出プログラムの作成とOSSへの適用`
  - https://www.slideshare.net/ssuser9ef9aa/redos
  - https://www.slideshare.net/ssuser9ef9aa/redososs
- [13] `The Regular Expression Denial of Service (ReDoS) cheat-sheet | by James Davis | Level Up Coding`
  - https://levelup.gitconnected.com/the-regular-expression-denial-of-service-redos-cheat-sheet-a78d0ed7d865
- [14] `GitHub - NicolaasWeideman/RegexStaticAnalysis: A tool to perform static analysis on regexes to determine whether they are vulnerable to ReDoS.`
  - https://github.com/NicolaasWeideman/RegexStaticAnalysis
- [15] `Static Analysis of Regular Expressions`, Nicolaas Hendrik Weideman, 2017-12
  - https://core.ac.uk/download/pdf/188223352.pdf
  - 後発なだけあり、英語だが比較的よくまとめられている。IDAについての勘違いもこれで解決することができた。

