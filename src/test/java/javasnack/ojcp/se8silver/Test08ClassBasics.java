package javasnack.ojcp.se8silver;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.List;

import org.junit.jupiter.api.Test;

import javasnack.ojcp.se8silver.test08sub.AccessScopeDemo;

public class Test08ClassBasics {
    // OOP関連は一般的な入門書で一通りは解説されているため、
    // 普段使わなかったり気にしたことの無かったコーナーケース・エッジケースを主に試す。

    // final を付けた場合、初期化なしは compile error
    //final int finalInt;
    // 代入演算子も compile error
    //int x += 10;

    byte ibyte;
    short ishort;
    int iint;
    long ilong;
    float ifloat;
    double idouble;
    boolean iboolean;
    String iString;

    // instance/static で同じフィールド名/メソッド名は使えない。
    //static byte ibyte;
    void instanceMethod() {
    }

    //static void instanceMethod() {
    //}

    static byte sibyte;
    static short sishort;
    static int siint;
    static long silong;
    static float sifloat;
    static double sidouble;
    static boolean siboolean;
    static String siString;

    static String staticStringX = "hello";
    static {
        staticStringX += "world";
    }

    @Test
    public void testFieldDefaultValues() {
        assertThat(ibyte).isEqualTo((byte) 0);
        assertThat(ishort).isEqualTo((short) 0);
        assertThat(iint).isEqualTo(0);
        assertThat(ilong).isEqualTo(0L);
        assertThat(ifloat).isEqualTo(0.0f);
        assertThat(idouble).isEqualTo(0.0);
        assertThat(iboolean).isEqualTo(false);
        assertThat(iString).isNull();
        assertThat(sibyte).isEqualTo((byte) 0);
        assertThat(sishort).isEqualTo((short) 0);
        assertThat(siint).isEqualTo(0);
        assertThat(silong).isEqualTo(0L);
        assertThat(sifloat).isEqualTo(0.0f);
        assertThat(sidouble).isEqualTo(0.0);
        assertThat(siboolean).isEqualTo(false);
        assertThat(siString).isNull();
        assertThat(staticStringX).isEqualTo("helloworld");
    }

    @Test
    public void testVoidSetter() {
        class VoidSetter {
            int id = 1;

            void setId(int id) {
                // これは compile 自体は ok.
                id = id;
            }
        }

        VoidSetter o1 = new VoidSetter();
        assertThat(o1.id).isEqualTo(1);
        o1.setId(10);
        // setId() 中で this. を付けていないため、
        // 肝心のインスタンスメンバを更新できていない。
        assertThat(o1.id).isEqualTo(1);
    }

    @Test
    public void testDefaultConstructorDemo() {
        // call default constructor (generated by java compiler)
        class DefaultConstructorDemo1 {
            int id = 10;
        }

        DefaultConstructorDemo1 o1 = new DefaultConstructorDemo1();
        assertThat(o1.id).isEqualTo(10);

        // コンストラクタを1つでも定義すると、デフォルトコンストラクタは作られない。
        class DefaultConstructorDemo2 {
            int id = 10;

            public DefaultConstructorDemo2(int id) {
                this.id = id;
            }
        }
        // -> new DefaultConstructorDemo2() で compile error
        //DefaultConstructorDemo2 o2 = new DefaultConstructorDemo2();
        DefaultConstructorDemo2 o2 = new DefaultConstructorDemo2(20);
        assertThat(o2.id).isEqualTo(20);

        // インスタンスフィールドでの初期化が終わったあとに、コンストラクタが呼ばれる。
        class DefaultConstructorDemo3 {
            int id = 10;

            public DefaultConstructorDemo3() {
                this.id = 30;
            }
        }
        DefaultConstructorDemo3 o3 = new DefaultConstructorDemo3();
        assertThat(o3.id).isEqualTo(30);
    }

    static class MethodOverloadDemo {
        public String m1() {
            return "hello";
        }

        // 戻り値の型が違うだけの overload は compile error
        //public void m1() {
        //}

        public String m1(int i) {
            return "int:" + i;
        }

        public String m1(long i) {
            return "long:" + i;
        }

        // >#>POINT<#<: 戻り値の型 + 引数セットが異なれば overload 可能
        public void m1(StringBuilder modify) {
            modify.append("aaa");
        }

        public String m1(Integer i) {
            return "Integer:" + i;
        }

        public String m1(Number n) {
            return "Number:" + n.toString();
        }

        public String m1(List<String> strings) {
            return "List<String>:" + strings.toString();
        }

        /* >#>POINT<#< : 単純なジェネリクス型が異なるだけでは compile error
        public String m1(List<Integer> ints) {
            return "List<Integer>:" + ints.toString();
        }
        */

        public String m1(Object o) {
            return "Object:" + o.toString();
        }

        public void m2() {
        }

        // アクセス修飾子が異なるだけの overload は compile error
        //private void m2() {
        //}

        // overload ではアクセス修飾子を変更できる。
        @SuppressWarnings("unused")
        private void m2(int i) {
        }

        protected void m2(int i, int j) {
        }

        public void m3() {
        }

        // instance method / static method で戻り値型,引数セットが同じ場合、
        // 同じメソッド名は使えない (compile error)
        //public static void m3() {
        //}
        // instance method / static method で引数セットが同じ <> 戻り値型が異なる場合も、
        // 同じメソッド名は使えない (compile error)
        //public static String m3() {
        //    return "";
        //}
        // >#>POINT<#< : 引数セットが異なれば、
        // instance/static method で同じメソッド名が使える。
        public static void m3(StringBuilder sb) {
            sb.append("static m3()");
        }

        public void m4() {
        }

        // 引数セットが異なり、さらに戻り値型も異なるので同じメソッド名が使える。
        public static String m4(StringBuilder sb) {
            sb.append("static m4()");
            return sb.toString();
        }
    }

    @Test
    public void testMethodOverloadDemo() {
        MethodOverloadDemo o1 = new MethodOverloadDemo();
        assertThat(o1.m1()).isEqualTo("hello");
        /* >#>POINT<#<:
         * overload されたメソッドを呼び出す優先順位:
         * 完全一致 > implicit type cast > auto boxing > varargs
         */
        assertThat(o1.m1(10)).isEqualTo("int:10");
        long longv1 = 1_000_000_000_000L;
        assertThat(o1.m1(longv1)).isEqualTo("long:1000000000000");
        StringBuilder sb = new StringBuilder("xxx");
        o1.m1(sb);
        assertThat(sb.toString()).isEqualTo("xxxaaa");
        assertThat(o1.m1(Integer.valueOf(20))).isEqualTo("Integer:20");
        assertThat(o1.m1(Long.valueOf(30))).isEqualTo("Number:30");
        assertThat(o1.m1(List.of("aaa", "bbb", "ccc"))).isEqualTo("List<String>:[aaa, bbb, ccc]");
        assertThat(o1.m1(new int[] { 1, 2, 3, 4, 5 })).startsWith("Object:[I@");

        sb = new StringBuilder("xxx");
        o1.m3();
        MethodOverloadDemo.m3(sb);
        assertThat(sb.toString()).isEqualTo("xxxstatic m3()");
        sb = new StringBuilder("yyy");
        o1.m4();
        assertThat(MethodOverloadDemo.m4(sb)).isEqualTo("yyystatic m4()");
    }

    @Test
    public void testAccessScopeDemo() {
        AccessScopeDemo o1 = new AccessScopeDemo();
        assertThat(o1.mPublic()).isEqualTo("public scope method");
        // パッケージ外 + 継承関係にも無いためアクセスNG (compile error)
        //o1.mProtected();
        // パッケージ外のためアクセスNG (compile error)
        //o1.mPackage();
        // private のためアクセスNG (compile error)
        //o1.mPrivate();

        class AccessScopeDemoT2 extends AccessScopeDemo {
            public String m3() {
                // パッケージ外だが継承関係があるためアクセスOK
                return mProtected();
            }
        }
        AccessScopeDemoT2 o2 = new AccessScopeDemoT2();
        assertThat(o2.m3()).isEqualTo("protected scope method");

        // 外部 .java 内の non-public class なのでアクセスNG (compile error)
        //AccessScopeDemoNonScoped o3 = new AccessScopeDemoNonScoped();
    }

    // GC での finalize() はテストが難しいので、compile ok だけ確認。
    static class FinalizeDemo {
        // >#>POINT<#< : 元が protected.
        // そのまま override すると継承元の finalize() が呼ばれないので、
        // super.finalize() で明示的に呼ぶ必要がある。
        @SuppressWarnings("deprecation")
        protected void finalize() throws Throwable {
            super.finalize();
        }
    }
}
